**获取验证码**测试：

- **获取成功（已测试）**

  输入：邮箱

  输出：验证码已发送

- **验证码还未过期（已测试）**

  输入：已发送过验证码的邮箱，且验证码未过期

  输出：原验证码未过期

**注册**测试：

- **未获取验证码（已测试）**

  输入：未获取验证码，随便输入一个验证码

  输出：未获取验证码或验证码过期

- **验证码过期（已测试）**

  输入：获取验证码，但超时后再用该验证码注册

  输出：未获取验证码或验证码过期

- **验证码错误（已测试）**

  输入：获取验证码，但输入与正确验证码不同的字符

  输出：验证码错误

- **注册成功（已测试）**

  输入：获取验证码，并输入正确验证码，且邮箱未被注册

  输出：注册成功

- 邮箱已被注册

  输入：获取验证码，并输入正确验证码，且邮箱已被注册

  输出：该邮箱已注册

登录测试：

- 邮箱未注册

  输入：未注册的邮箱，密码

  输出：邮箱未注册

- 密码错误

  输入：已注册的邮箱，错误的密码

  输出：密码错误

- 登录成功

  输入：已注册的邮箱，正确的密码

  输出：注册成功



多线程Bug的解决：

1. 问题：对OrderedDict的操作，在注册成功时也要删除验证码，也可能在定期时删除，可能导致KeyError。

   解决：使用try-except 捕获错误。

2. 问题：在所有验证码清空后，调度器关闭（性能考虑），所以在获取验证码时，可能需要重新开启调度器（计时器），可能导致多次开启。

   解决：使用一个布尔值 is_scheduler_running 判定调度器是否在运行，并且为其加锁（具体见源代码）。

3. 在所有验证码清空后，调度器关闭，在下次验证码请求时再开启，但可能最后一次删除验证码的函数还没执行完毕（执行到判断验证码为空），有一个验证码请求来了，然后又调回删除验证码的函数继续运行，由于当时判断验证码为空，所以关闭了调度器。此后如果没有验证码请求，那么将没有调度器开启，保存的验证码永远不会被删除。

   解决：在关闭调度器之后，判断验证码是否不为空，且调度器未开启，若是，则开启调度器。



查询任务列表：

- 根据time

- 根据publisher_id
- 根据accepter_id
- 根据tag
- 根据title、content



项目其他部分可能的Bug：

- 往下加载任务时，应加载后面的记录；(在本地记录最老时间戳)

- 往上刷新任务时，应加载最新记录。